#pragma once

namespace ermia {

namespace dlog {

// CSNs are 64-bit integers and are global; used for ordering transactions.
// TLog LSNs (not to be confused with the "LSN" defined by sm-common.h and
// encoded in a fat_ptr) are 64-bit integers and are local to a log; the <log
// id, lsn> pair uniquely identifies a log record.
//
// Note that out of the 64 bits, an LSN only uses 40 bits out of it, limiting
// the max size of each tlog to 1TB. The rationale is to still be able to fit
// the <log id, LSN> pair in 48 bits---which is the number of bits available in
// a fat_ptr---so that we can encode a <log id, lsn> pair in a single fat_ptr.
// Then log ids are 8-bit integers. This allows us to support up to 2^8=256
// tlogs, i.e., 256 cores maximum. Should these limitations become a problem, we
// could expand fat_ptrs to 16B.
typedef uint64_t tlog_csn;
typedef uint64_t tlog_lsn;
static const tlog_csn INVALID_TLOG_CSN = ~uint64_t{0};
static const tlog_lsn INVALID_TLOG_LSN = ~uint64_t{0};

// A log block is the collection of log records generated by a transaction. A
// transaction could have mutliple log blocks or a single one if the log block
// is big enough to hold all the log records, this is further determined by the
// log buffer and segment sizes - we cannot allow a log block to span two log
// buffers or segments.
//
// Note that it is the "user's" job to populate a log block by laying out all
// log records (log_record instances, one of another) in the [payload] part of
// this structure, i.e., the log block here doesn't interpret the content of the
// payload; it doesn't know about concepts such as FIDs and OIDs, which are up
// to the user of dlog to use. Consequently, there is no "log record" concept
// for dlog. This helps us keep a clean separation between dlog and its users.
//
// Upon commit dlog only deals with log blocks and copies log blocks in their
// entirety to the log buffer from the transaction's scratch area (provided by
// the caller).
struct log_block {
  // CSN of the transaction who created this log block
  tlog_csn csn;

  // Size of this log block in bytes
  uint32_t payload_size;

  // Total capacity of this log block (could be greater than payload_size)
  uint32_t capacity;

  char padding[PAGE_SIZE- sizeof(csn) - sizeof(payload_size) - sizeof(capacity)];

  // Actual data, which in turn is an array of log records;
  // must be the last element
  char payload[0];

  log_block(uint32_t cap) : csn(INVALID_TLOG_CSN), payload_size(0), capacity(cap) {}
  ~log_block() {}

  // Size of this whole log block
  inline uint32_t total_size() { return sizeof(*this) + payload_size; }

  inline char *get_payload() { return &payload[0]; }
};
}  // namespace dlog

}  // namespace ermia
